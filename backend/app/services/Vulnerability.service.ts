import { mapMetrics, mapWeaknesses, mapAffected, mapReferences } from "../models/map";
import { environment } from "../../env";
import {  Pagination, Vulnerability} from "../models";


import { VulnerabilityRepository } from "../repository";
import axios from 'axios';

export class VulnerabilityService {
    private readonly apiBaseUrl = environment.api.baseUrl;
    private readonly apiKey = environment.api.apiKey;
    private readonly  virtualMatchString = `cpe:2.3:h:*:*:*:*:*:*:*:*:*:*`;


    private async sleep(ms: number) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }


    public async bulkCreate(vulnerabilites: Vulnerability[]) {
        return await VulnerabilityRepository.bulkCreate(vulnerabilites);
      }


      public async find(p?: Pagination) {

        if (p !== undefined) {
          p.totalCount = await VulnerabilityRepository.count();
          return await VulnerabilityRepository.find({
            order: {
              id: "DESC",
            },

            relations: ["affected", "metrics", "weaknesses", "references"],
    
            skip: p ? p.limit * (p.page - 1) : 0,
            take: p ? p.limit : 0,
          });
        }
        return await VulnerabilityRepository.find(
          { relations: ["affected", "metrics", "weaknesses", "references"] }
        );

      }
    
      public async findOneById(id: number) {
        return await VulnerabilityRepository.findOneBy({
          id: id,
          
        });
      }

      //and relashions are
      public async findOneByCveId(cveId: string) {
        return await VulnerabilityRepository.findByCveId(cveId);
      }


      public async save(vulnerability: Vulnerability) {
        return await VulnerabilityRepository.save(vulnerability);

      }


      public async create(lastModStartDate?: Date): Promise<void> {
        try {
            // Mise à jour de la limite resultsPerPage en tenant compte de la nouvelle limite de 500
            const resultsPerPage: number = 500;
            let startIndex: number = 0;
            let totalResults: number = Infinity;
            const waitTime = 6;
    
    
            while (startIndex < totalResults) {
                console.log(`Fetching data from NVD: startIndex=${startIndex}`);
                let url = `${this.apiBaseUrl}?virtualMatchString=${this.virtualMatchString}&resultsPerPage=${resultsPerPage}&startIndex=${startIndex}`;

                if (lastModStartDate) {
                  url += `&lastModStartDate=${lastModStartDate.toISOString()}&lastModEndDate=${new Date().toISOString()}`;
                }

                const response = await axios.get(
                    url,
                    {
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.apiKey}`,
                        },
                    }
                );
    
                const data = response.data;
                console.log(`Fetched data from NVD: ${data.totalResults} results`);

                if (startIndex === 0){
                  totalResults = data.totalResults;
                }
    
                const vulnerabilities = data.vulnerabilities;
                await this.saveVulnerabilities(vulnerabilities);
                // console.log('Saving vulnerabilities to database');
                startIndex += resultsPerPage;
                // Attendre 30 secondes avant de faire une autre requête
                const display = startIndex < totalResults ? `Waiting ${waitTime} seconds before next request` : 'Done!';
                console.log(display);
                await this.sleep(waitTime*1000);
            }
        } catch (error) {
            console.error('Error fetching data from NVD:', error);
            throw error;
        }
    }

    
      
      private async saveVulnerabilities(vulnerabilities: any[]): Promise<void> {
        const promises = vulnerabilities.map(async (vulnData) => {
            const cveId: string = vulnData.cve.id;
            const criteria: string | undefined = vulnData.cve.configurations?.[0]?.nodes[0]?.cpeMatch[0]?.criteria; 
            try {
                // Vérification de l'existence de la vulnérabilité
                const existingVulnerability = await this.findOneByCveId(cveId);
                if (existingVulnerability.length > 0) {
                    console.log(`Vulnerability ${cveId} already exists`);
                    return;
                }
                // Création d'une nouvelle vulnérabilité
                const vulnerability = new Vulnerability();
                vulnerability.cveId = cveId;
                vulnerability.vendor = criteria?.split(':')[3] || '';
                vulnerability.product = criteria?.split(':')[4] || '';
                vulnerability.sourceIdentifier = vulnData.cve.sourceIdentifier;
                vulnerability.description = vulnData.cve.descriptions[0]?.value || '';
                vulnerability.published = vulnData.cve.published;
                vulnerability.lastModified = vulnData.cve.lastModified;
                vulnerability.metrics = mapMetrics(vulnData.cve);
                vulnerability.weaknesses = mapWeaknesses(vulnData.cve);
                vulnerability.affected = mapAffected(vulnData.cve);
                vulnerability.references = mapReferences(vulnData.cve);

                console.log(`Saving vulnerability ${cveId}`);
                // Enregistrement de la nouvelle vulnérabilité
                return await this.save(vulnerability);
                
            } catch (error) {
                console.error('Error saving vulnerability:', error);
                throw error;
            }
        });
    
        await Promise.all(promises);
    }


   public async countDistinctProducts() {

    try {

      const vuln = await VulnerabilityRepository.find();
      if (vuln) {
        const totalProducts = new Set(vuln.map(vuln => vuln.product)).size;
        return totalProducts;
      }
      return 0;
      
    } catch (error) {

      console.error('Error fetching vulnerabilities:', error);
      return 0;

    }



   
   }


   public async countDistinctVendors() {

    try {

      const vuln = await VulnerabilityRepository.find();
      if (vuln) {
        const totalVendors = new Set(vuln.map(vuln => vuln.vendor)).size;
        return totalVendors;
      }
      return 0;
      
    } catch (error) {

      console.error('Error fetching vulnerabilities:', error);
      return 0;

    }
   }


  /**
   * Get all vendors
   * @returns {Promise<string[]>} List of vendors
   * @memberof VulnerabilityService
   */
   public async getAllVendors(): Promise<string[]> {
      
      try {
  
        const vuln = await VulnerabilityRepository.find();
        if (vuln) {
          const vendors = new Set(vuln.map(vuln => vuln.vendor));
          return Array.from(vendors);
        }
        return [];
        
      } catch (error) {
  
        console.error('Error fetching vulnerabilities:', error);
        return [];
  
      }
  }

  /**
   * Get all products
   * @returns {Promise<string[]>} List of products
   * @memberof VulnerabilityService
   */

  public async getAllProducts(): Promise<string[]> {
      
    try {

      const vuln = await VulnerabilityRepository.find();
      if (vuln) {
        const products = new Set(vuln.map(vuln => vuln.product));
        return Array.from(products);
      }
      return [];
      
    } catch (error) {

      console.error('Error fetching vulnerabilities:', error);
      return [];

    }
  }

  /**
   * @memberof VulnerabilityService
   * @param {string} product
   */

  public async getVulnerabilitiesByProduct(product: string) {
    return await VulnerabilityRepository.findByProduct(product);
  }

  /**
   * @memberof VulnerabilityService
   * @param {string} vendor
   */
  public async getVulnerabilitiesByVendor(vendor: string) {
    return await VulnerabilityRepository.findByVendor(vendor);
  }


    
      

}
