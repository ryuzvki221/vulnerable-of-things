import { Request, Response } from "express";
import { Pagination, Vulnerability } from "../models";
import { VulnerabilityService } from "../services";
import { Controller } from "./Controller";

export class VulnerabilityController extends Controller {

    private readonly vulnService: VulnerabilityService;
    private pagination: Pagination = { page: 1, limit: 10 };
    
    constructor(req: Request, res: Response) {
        super(req, res);
        this.vulnService = new VulnerabilityService();

    }
     //@URL: http://127.0.0.1:4000/api/v1/cve?page=3&limit=1
     public async all(): Promise<Response> {
        try {
            const { page, limit } = this.req.query;
    
            // Déterminer la pagination ou retourner toutes les données si elle n'est pas définie
            const currentPage = page !== undefined ? Number(page) : this.pagination.page;
            const limitPage = limit !== undefined ? Number(limit) : this.pagination.limit;
            this.pagination.page = currentPage;
            this.pagination.limit = limitPage;
    
            // Récupérer les vulnérabilités en fonction de la pagination ou de toutes les données
            const vulnerabilities = await (page && limit ? this.vulnService.find(this.pagination) : this.vulnService.find());
    
            this.pagination.data = vulnerabilities;
    
            return this.res.send(this.pagination.data);
        } catch (error) {
            console.error('Error fetching vulnerabilities:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }
    
    
    public async find(): Promise<Response> {
        try {
            const { id } = this.req.params;
            const vuln = await this.vulnService.findOneById(Number(id));
            return vuln ? this.res.status(200).send(vuln) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding vulnerability by ID:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }

    public async getProducts(): Promise<Response> {
        try {
            const products = await this.vulnService.getAllProducts();
            const totalProducts = products.length;
            return products ? this.res.status(200).send(
                {
                    totalProducts,
                    data: products
                }
            ) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding products:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }

    public async getVendors(): Promise<Response> {
        try {
            const vendors = await this.vulnService.getAllVendors();
            const totalVendors = vendors.length;
            return vendors ? this.res.status(200).send(
                {
                    totalVendors,
                    data: vendors
                }
            ) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding all vendors:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }

    public async findByCveId(): Promise<Response> {
        try {
            const { cveId } = this.req.params;
            const vuln = await this.vulnService.findOneByCveId(cveId);
            return vuln ? this.res.status(200).send(vuln) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding vulnerability by CVE ID:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }


    public async findByProduct(): Promise<Response> {
        try {
            const { product } = this.req.params;
            const vuln = await this.vulnService.getVulnerabilitiesByProduct(product);
            return vuln ? this.res.status(200).send(vuln) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding vulnerability by product:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }

    public async findByVendor(): Promise<Response> {
        try {
            const { vendor } = this.req.params;
            const vuln = await this.vulnService.getVulnerabilitiesByVendor(vendor);
            return vuln ? this.res.status(200).send(vuln) : this.res.status(404).send({ text: "not found" });
        } catch (error) {
            console.error('Error finding vulnerability by vendor:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }

    public async create(): Promise<Response> {
        try {
            await this.vulnService.create();
            return this.res.status(201).json({ message: 'Vulnerabilities saved successfully' });
        } catch (error) {
            console.error('Error saving vulnerabilities:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }


    public async update(): Promise<Response> {
        try {
           const { date } = this.req.params;
           console.log(`Updating vulnerabilities for date ${new Date(date)}`);
           const vuln = await this.vulnService.create(new Date(date));
           if (vuln !== undefined) {
            return this.res.status(200).json({ message: 'updating' });
           }
            return this.res.status(404).json({ message: 'Up to date' });

        } catch (error) {
            console.error('Error updating vulnerability:', error);
            return this.res.status(500).json({ message: 'Internal server error' });
        }
    }
}
